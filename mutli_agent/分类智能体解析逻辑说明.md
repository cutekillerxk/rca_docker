# 分类智能体解析逻辑说明

## 一、解析流程概述

分类智能体（`FaultClassifierAgent`）的`parse_output`方法负责解析LLM返回的分类结果。解析过程分为以下几个阶段：

1. **预处理**：移除markdown代码块标记
2. **JSON解析**：尝试解析JSON格式
3. **字段验证**：验证必需字段，补充缺失字段
4. **容错处理**：JSON解析失败时的降级处理

---

## 二、详细解析逻辑

### 2.1 预处理阶段（`classifier.py:139-147`）

```python
# 移除可能的markdown代码块标记
response = response.strip()
if response.startswith("```json"):
    response = response[7:]  # 移除 ```json
elif response.startswith("```"):
    response = response[3:]  # 移除 ```
if response.endswith("```"):
    response = response[:-3]  # 移除结尾的 ```
response = response.strip()
```

**目的**：处理LLM可能返回的markdown格式代码块，提取纯JSON内容。

**示例**：
- 输入：` ```json\n{"fault_type": "datanode_down"}\n``` `
- 输出：`{"fault_type": "datanode_down"}`

---

### 2.2 JSON解析阶段（`classifier.py:149-150`）

```python
# 解析JSON
result_dict = json.loads(response)
```

**成功情况**：如果JSON格式正确，继续后续验证。

**失败情况**：抛出`json.JSONDecodeError`异常，进入容错处理（见2.5节）。

---

### 2.3 字段验证阶段（`classifier.py:152-163`）

#### 2.3.1 验证必需字段 `fault_type`

```python
if "fault_type" not in result_dict:
    raise ValueError("缺少必需字段: fault_type")
```

**说明**：`fault_type`是必需字段，如果缺失会抛出异常，进入容错处理。

---

#### 2.3.2 补充缺失字段 `confidence`

```python
if "confidence" not in result_dict:
    result_dict["confidence"] = 0.5  # 默认置信度
```

**说明**：如果`confidence`字段缺失，使用默认值`0.5`（50%置信度）。

---

#### 2.3.3 补充缺失字段 `category`（关键逻辑）

```python
if "category" not in result_dict:
    # 从故障类型库中获取category
    fault_type = result_dict["fault_type"]
    if fault_type in FAULT_TYPE_LIBRARY:
        result_dict["category"] = FAULT_TYPE_LIBRARY[fault_type]["category"]
    else:
        result_dict["category"] = "generic"  # ⚠️ 输出generic类型
```

**逻辑说明**：

1. **如果`category`字段缺失**：
   - 首先检查`fault_type`是否在`FAULT_TYPE_LIBRARY`中
   - **如果在库中**：从库中获取对应的`category`（如`"hdfs"`、`"yarn"`、`"mapreduce"`）
   - **如果不在库中**：设置为`"generic"` ⚠️

2. **输出`generic`类型的情况**：
   - LLM返回的`fault_type`不在已知故障类型库中
   - 例如：LLM返回`{"fault_type": "custom_fault", "confidence": 0.8}`，但`"custom_fault"`不在`FAULT_TYPE_LIBRARY`中
   - 结果：`{"fault_type": "custom_fault", "category": "generic", ...}`

---

### 2.4 创建分类结果对象（`classifier.py:165-174`）

```python
# 创建ClassificationResult对象
classification = ClassificationResult(
    fault_type=result_dict["fault_type"],
    confidence=float(result_dict["confidence"]),
    category=result_dict["category"],
    related_faults=result_dict.get("related_faults"),
    reasoning=result_dict.get("reasoning")
)

return classification.to_dict()
```

**说明**：如果所有验证通过，创建`ClassificationResult`对象并返回字典格式。

---

### 2.5 容错处理阶段（`classifier.py:176-196`）

当JSON解析失败时，会进入容错处理流程：

#### 2.5.1 尝试提取JSON部分（`classifier.py:177-184`）

```python
except json.JSONDecodeError as e:
    # JSON解析失败，尝试提取JSON部分
    json_match = re.search(r'\{.*\}', response, re.DOTALL)
    if json_match:
        try:
            result_dict = json.loads(json_match.group())
            return result_dict  # 如果提取成功，直接返回
        except:
            pass
```

**说明**：使用正则表达式提取响应中的JSON部分（`{...}`），如果提取成功且能解析，直接返回。

**示例**：
- 输入：`"根据分析，故障类型是：{\"fault_type\": \"datanode_down\"}"`
- 提取：`{"fault_type": "datanode_down"}`
- 解析成功：返回结果

---

#### 2.5.2 完全失败时的默认结果（`classifier.py:186-196`）

```python
# 如果还是失败，返回错误信息
print(f"[WARNING] 分类输出解析失败: {e}")
print(f"[WARNING] 原始响应: {response[:200]}")

# 返回默认分类结果
return {
    "fault_type": "unknown",      # ⚠️ 输出unknown类型
    "confidence": 0.0,            # 置信度为0
    "category": "generic",         # ⚠️ category为generic
    "reasoning": f"解析失败: {str(e)}"
}
```

**说明**：如果JSON解析完全失败（包括提取JSON部分也失败），返回默认结果。

**输出`unknown`类型的情况**：
- LLM返回的响应不是有效的JSON格式
- 无法从响应中提取JSON部分
- 例如：
  - LLM返回纯文本：`"根据日志分析，可能是DataNode问题"`
  - LLM返回格式错误：`{fault_type: datanode_down}`（缺少引号）
  - LLM返回空响应：`""`
- 结果：`{"fault_type": "unknown", "category": "generic", "confidence": 0.0, ...}`

---

## 三、输出类型总结

### 3.1 `generic`类型输出情况

| 情况 | 代码位置 | 触发条件 | 示例 |
|------|---------|---------|------|
| **情况1** | `classifier.py:163` | `category`字段缺失，且`fault_type`不在`FAULT_TYPE_LIBRARY`中 | LLM返回：`{"fault_type": "custom_fault", "confidence": 0.8}`<br>结果：`{"fault_type": "custom_fault", "category": "generic", ...}` |
| **情况2** | `classifier.py:194` | JSON解析完全失败 | LLM返回：`"无法确定故障类型"`<br>结果：`{"fault_type": "unknown", "category": "generic", ...}` |

---

### 3.2 `unknown`类型输出情况

| 情况 | 代码位置 | 触发条件 | 示例 |
|------|---------|---------|------|
| **唯一情况** | `classifier.py:192` | JSON解析完全失败 | LLM返回：`"根据日志分析..."`（纯文本）<br>结果：`{"fault_type": "unknown", "category": "generic", "confidence": 0.0, ...}` |

**注意**：`unknown`类型**总是**伴随着`category: "generic"`。

---

## 四、故障类型库说明

### 4.1 已知故障类型

`FAULT_TYPE_LIBRARY`中定义的故障类型及其`category`：

| 故障类型 | category | 说明 |
|---------|---------|------|
| `datanode_down` | `hdfs` | DataNode下线 |
| `namenode_safemode` | `hdfs` | NameNode安全模式 |
| `cluster_id_mismatch` | `hdfs` | 集群ID不匹配 |
| `resourcemanager_down` | `yarn` | ResourceManager下线 |
| `nodemanager_down` | `yarn` | NodeManager下线 |
| `yarn_config_error` | `yarn` | YARN配置错误 |
| `mapreduce_memory_insufficient` | `mapreduce` | MapReduce任务内存不足 |
| `mapreduce_disk_insufficient` | `mapreduce` | MapReduce任务磁盘空间不足 |
| `mapreduce_shuffle_failed` | `mapreduce` | MapReduce Shuffle阶段失败 |
| `mapreduce_task_timeout` | `mapreduce` | MapReduce任务超时 |

### 4.2 不在库中的故障类型

如果LLM返回的`fault_type`不在上述列表中，且`category`字段缺失，会自动设置为`"generic"`。

**示例**：
- LLM返回：`{"fault_type": "network_timeout", "confidence": 0.7}`
- 解析结果：`{"fault_type": "network_timeout", "category": "generic", "confidence": 0.7}`

---

## 五、专家选择逻辑

### 5.1 根据category选择专家（`expert_selector.py:44-55`）

```python
if category == "hdfs":
    primary_experts = ["hdfs_expert"]
elif category == "yarn":
    primary_experts = ["yarn_expert"]
elif category == "mapreduce":
    primary_experts = ["mapreduce_expert"]
else:
    primary_experts = ["generic_expert"]  # ⚠️ generic类型选择通用专家
```

**说明**：
- `category`为`"hdfs"`、`"yarn"`、`"mapreduce"`时，选择对应的专业专家
- `category`为`"generic"`时，选择`generic_expert`（通用专家）

### 5.2 未知故障类型的选择（`expert_selector.py:93-95`）

```python
if fault_type not in self.fault_expert_mapping:
    # 未知故障类型，返回通用专家
    return ["generic_expert"]
```

**说明**：如果`fault_type`不在故障类型库中（包括`"unknown"`），也会选择`generic_expert`。

---

## 六、实际场景示例

### 场景1：正常分类成功

**LLM返回**：
```json
{
  "fault_type": "datanode_down",
  "confidence": 0.95,
  "category": "hdfs",
  "reasoning": "监控指标显示NumDeadDataNodes > 0"
}
```

**解析结果**：
```python
{
    "fault_type": "datanode_down",
    "confidence": 0.95,
    "category": "hdfs",  # ✅ 从库中获取
    "reasoning": "监控指标显示NumDeadDataNodes > 0"
}
```

**专家选择**：`["hdfs_expert"]`

---

### 场景2：category缺失但fault_type在库中

**LLM返回**：
```json
{
  "fault_type": "datanode_down",
  "confidence": 0.95
}
```

**解析结果**：
```python
{
    "fault_type": "datanode_down",
    "confidence": 0.95,
    "category": "hdfs"  # ✅ 从FAULT_TYPE_LIBRARY中自动获取
}
```

**专家选择**：`["hdfs_expert"]`

---

### 场景3：fault_type不在库中（输出generic）

**LLM返回**：
```json
{
  "fault_type": "network_partition",
  "confidence": 0.8
}
```

**解析结果**：
```python
{
    "fault_type": "network_partition",
    "confidence": 0.8,
    "category": "generic"  # ⚠️ 不在库中，设置为generic
}
```

**专家选择**：`["generic_expert"]`

---

### 场景4：JSON解析失败（输出unknown + generic）

**LLM返回**：
```
根据日志分析，可能是DataNode连接问题，但无法确定具体故障类型。
```

**解析过程**：
1. 尝试解析JSON：失败（不是JSON格式）
2. 尝试提取JSON部分：失败（没有`{...}`格式）
3. 返回默认结果

**解析结果**：
```python
{
    "fault_type": "unknown",      # ⚠️ 解析失败
    "confidence": 0.0,            # 置信度为0
    "category": "generic",        # ⚠️ 默认generic
    "reasoning": "解析失败: Expecting value: line 1 column 1 (char 0)"
}
```

**专家选择**：`["generic_expert"]`

---

### 场景5：Markdown格式的JSON

**LLM返回**：
````
```json
{
  "fault_type": "datanode_down",
  "confidence": 0.9
}
```
````

**解析过程**：
1. 移除markdown标记：`{"fault_type": "datanode_down", "confidence": 0.9}`
2. 解析JSON：成功
3. 补充`category`：从库中获取`"hdfs"`

**解析结果**：
```python
{
    "fault_type": "datanode_down",
    "confidence": 0.9,
    "category": "hdfs"
}
```

**专家选择**：`["hdfs_expert"]`

---

## 七、总结

### 7.1 输出`generic`类型的情况

1. **`fault_type`不在故障类型库中**（`classifier.py:163`）
   - LLM返回了未知的故障类型
   - `category`字段缺失或不在库中
   - 自动设置为`"generic"`

2. **JSON解析完全失败**（`classifier.py:194`）
   - 无法解析LLM返回的响应
   - 返回默认结果，`category`为`"generic"`

### 7.2 输出`unknown`类型的情况

1. **JSON解析完全失败**（`classifier.py:192`）
   - LLM返回的不是有效的JSON格式
   - 无法从响应中提取JSON部分
   - `fault_type`设置为`"unknown"`，`category`为`"generic"`

### 7.3 关键代码位置

| 输出类型 | 代码位置 | 触发条件 |
|---------|---------|---------|
| `generic` | `classifier.py:163` | `fault_type`不在库中 |
| `generic` | `classifier.py:194` | JSON解析失败（伴随`unknown`） |
| `unknown` | `classifier.py:192` | JSON解析完全失败 |

### 7.4 专家选择

- `category: "generic"` → 选择`generic_expert`
- `fault_type: "unknown"` → 选择`generic_expert`
- `fault_type`不在库中 → 选择`generic_expert`

---

## 八、改进建议

1. **增强JSON提取**：可以尝试更复杂的正则表达式提取JSON
2. **LLM Prompt优化**：在system prompt中更明确要求输出JSON格式
3. **日志记录**：记录所有解析失败的情况，用于优化prompt
4. **重试机制**：如果解析失败，可以要求LLM重新输出
